/**********************************************************
* HW3: Metro Simulator
* Comp 15
* README
* Deanna Oei 
* October 6, 2020
*********************************************************/

Compile/run:
     - Compile using
            make MetroSim
     - run executable with
            ./MetroSim stationsFile passFile [commands]

Program Purpose:

    This homework assignment handles a running train to accommodate passengers 
arriving at a station, riding the metro, and departing at their destination. 
The purpose was to design and create an implementation to modularize
code and work with documented libraries. To accomplish this, this program uses
vectors of structs and queues.

Acknowledgements: 
    Thank you to Professor Sheldon for his videos on queues and for answering
questions on the online forum. I learned about vectors from the website:
http://www.cplusplus.com/reference/vector/vector/. I learned about using 
files in C++ programs with "How to interact with files in C++" by Matias 
Korman, Supriya Sanjay, Ranjit Thomas, and Professor Sheldon. 
Thanks to the many TA's who helped me during office hours:
    Juliana - for helping me with my make file.
    Akash - for helping me plan out my program at the beginning.
    Julia - for helping me make a clearer plan after getting started.
    Daniel - for helping me figure out which functions should be public or 
        private and for helping me visualize the train with its list of 
        PassengerQueues.
    Ryan - for helping me understand the input value for print() and how it 
        works between files, cout, and cerr.
    Kevin - for helping me debug my initializeTrain function write to the 
        output file. 
    Mateo - for helping me figure out which functions should be in my main.cpp
        and which should be in my MetroSim.cpp.
    Elise - for helping me figure out why my program was executing one more
        metro move than it was supposed to.

Files: 

main.cpp:
    Driver file for MetroSim, PassengerQueue, and Passenger classes. Contains
    main() function, reads in files, and executes the simulation.

MetroSim.h:
    Interface of MetroSim class. Declares the public and private functions and 
    member variables of the MetroSim class.
        
MetroSim.cpp:
    Implementation of MetroSim class. Includes key functions allowing the user
    to interact with a metro simulation. Deals with passengers going on/off 
    the train. Functions include: default constructor, destructor, 
    initializeStations, printTrain, printMap, askForInstructions,
    executeInstructions, initializeTrain, addPassenger, metroMove, embark,
    disembark, nextStationInd, writeOutput, readInStations, findDirections, 
    readInstructions.
    Also includes struct definitions: instruction, station, train.

PassengerQueue.h:
    Interface of PassengerQueue class. Declares public and private functions 
    and member variables of the PassengerQueue class.

PassengerQueue.cpp:
    Implementation of the PassengerQueue class. Contains definitions of key
    functions that allow the user interact with and modify PassengerQueues.
    Functions include: default constructor, destructor, front, back,
    dequeue, enqueue, print, createPassenger.

Passenger.h:
    Interface of Passenger class. Contains definition of struct Passenger.

Passenger.cpp:
    Implementation of the Passenger class. Contains function print().

testFile.cpp:
    Test driver file for MetroSim, PassengerQueue, and Passenger classes. 
    Contains main() and functions for unit testing functions among those 3 
    classes. Functions include: test_enque, test_dequeue, test_size,
    test_front, test_passengerQueue_print, test_passenger_print,
    test_initializeStations, test_printTrain, readInStations, findDirections,
    readInstructions.

stations.txt:
    A file listing example station names.
        
textStations.txt:
    A file listing 5 example station names used for unit testing.

test_commands.txt:
    Sample list of commands to give the simulator to execute.

output.txt:
    The output file used for unit testing. Contains a sample output from my
    most recent test. 
    
Makefile:
    File containing instructions for compiling and linking to create an 
    executable file.

README: 
    This file.

Data Structures:
    The data structures used in this program were vectors and queues. An 
    advantage of using vectors is that their size can change dynamically. 
    This is very convenient and more efficient than arrays for example as
    data doesn't need to be copied from one array to the other. Vectors
    also have ordered elements, which make it easier for users to access
    elements/data located in the middle of the vector compared to linked lists.
    A disadvantage of using vectors is that since their size can change
    dynamically, they allocate extra room for the potential growth, and this 
    consumes more memory.
    
    Queues use FIFO — first in, first out. An advantage to using queues are 
    it's easy to access and modify the elements at the end of the queue. 
    Elements in the queue are ordered and the size does not have to be 
    allocated beforehand like arrays. A disadvantage is that it's difficult 
    to access elements that are not at the ends. Queues' main functionality is
    to enqueue/dequeue, so the elements in the middle cannot be altered easily.

Testing:
    I started by writing the print function for the Passenger class and tested
    with test_passenger_print using various inputs. Then, I worked on the 
    PassengerQueue class functions. I repeated the process with size, front,
    enqueue, dequeue, and print. I started testing dequeue using a
    PassengerQueue of size 1. This seemed to work, but when I used a size
    higher than 1, the last element was disappearing instead of the front. I
    changed my function to utilize the vector clear and begin built in member
    functions which worked for multiple element PassengerQueues.
    
    While testing my initializingStations function, I noticed that my stations
    were all being initialized the same number. I had forgotten to increment 
    the numOfStations variable which counts how many stations are currently on 
    the map. 

    While writing printMap, my program would print out large seemingly random 
    numbers in place of station index numbers. The same thing happened while 
    writing my print function for PassengerQueues. After talking with a TA at 
    office hours, I learned it was because I had been using a vector of 
    pointers to a PassengerQueue and a vector of pointers to a station instead 
    of an instance of a PassengerQueue and an instance of a station. I switched
    from a vector of pointers to a normal vector and the print functions 
    printed out as expected. Majority of the bugs I encountered were actually 
    the result of my using vectors of pointers instead of normal instances. 
    addPassenger and printTrain also ran into address and printing issues which
    were fixed after I changed the vectors. 
    
    I had trouble designing a way to tell the program which way to take in 
    input (user or file), so I created a helper function findDirections. I ran
    tests with real text file names, fake text file names, and no text file 
    names to make sure it returned the correct output of “user” or “file”. If 
    findDirections returned “user”, I ran my userMove function which uses cin 
    in askForInstructions(). I had temporary cerr statements to make sure the 
    function was reading the inputs correctly. I used m m, m f, and p # #. A 
    bug I ran into was that after running m m after p # #, I was not able to 
    add any more passengers. I use booleans for my instruction struct to say 
    which kind of command was given. askForInstructions checks if m m or m f 
    were called first. m m was set to true before and had not been reset, 
    resulting in the train always moving but not being able to add more 
    passengers. I fixed this by initializing the booleans in the instructions 
    struct in MetroSim.h.
    
    (instruction struct, printTrain(), printMap(), and executeInstructions() 
    are all private functions. I made them public temporarily while testing,
    so they are currently commented out in testFile.cpp)

    I had trouble recording to the output file. This was not a problem with my
    writeOutput function but an issue with how and where I was calling it. I 
    had writeOutput as a member function of the MetroSim class and the input 
    for the file name was being provided in main(). I created a member variable
    outputFile to hold the name of the output file and ofstream object 
    outputObject to send the records to. 
    
    After my implementation seemed to be working, I tested it using different 
    cases such as adding passengers, moving the metro, and finishing the 
    program in different orders. I tested the train’s loop to make sure once it
    leaves the last station, it loops back up to the first station. I added 
    multiple passengers to station 2 and each gave them different destinations 
    to leave on. I added multiple passengers who had to wait for the train to 
    loop to make sure they wouldn’t get lost during the transition. eg in a map
    of 5 stations, p 3 2 would have to loop until getting to station 2. I 
    compared this all to the reference implementation to make sure it was 
    working properly by using diff and printing out the output files to 
    compare steps taken. A bug I encountered was when my given command file 
    ended on m m or p # # instead of m f. It would go one more step than the 
    reference. After going to office hours, I learned that my program would 
    rerun the last line of the program before ending because it hadn’t been 
    told it reached the end. I added in.eof so that the program would detect 
    the end of the line and finish where it left off instead of repeating an 
    instruction.